// FILE: ioutil.c
/*********************************************************************
 * ioutil.c
 * --------
 * Contains routines for reading user input, molecular orbital input,
 * and writing output.
 *
 *
 * By Christopher L Malbon
 * Dept of Chemistry, The Johns Hopkins University
 ********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "ioutil.h"

/** fortran subroutines **/
extern void _readmoints_(double *moints1, double *moints2,
			 long long int itype,
			 long long int orbitals,
			 long long int m1len,
			 long long int m2len,
			 double       *energy);

extern void _readnamelist_(long long int  nmlist,
			   unsigned char *nmlstr,
                           long long int *err);
/*************************/

int checkinputfiles()
/* checkinputfiles
 * ---------------
 * Check for the following input files:
 *  (1) = jayci.in    = input file containing &general and &diagalg namelists
 *  (2) = input.jayci = input file generated by jayci_exp.x
 *  (3) = moints      = molecular integral file
 *  (4) = det.list    = determinant input list
 * Returns integer value of missing input file.
 */
{
     /* local pointers 
      * fptr = file pointer */
     FILE *fptr;

     /* local scalars
      * err = error handling */
     int err;

     err = 0;
     
     fptr = fopen("jayci.in","r");
     if (fptr == NULL) {
	  err = 1;
	  fprintf(stderr,
		  "*** ERROR: Missing input file: jayci.in! ***\n");
	  return err;
     } else {
	  fclose(fptr);
     }

     fptr = fopen("input.jayci","r");
     if (fptr == NULL) {
	  err = 2;
	  fprintf(stderr,
		  "*** ERROR: Missing input file: input.jayci! ***\n");
	  return err;
     } else {
	  fclose(fptr);
     }

     fptr = fopen("moints", "r");
     if (fptr == NULL) {
	  err = 3;
	  fprintf(stderr,
		  "*** ERROR: Missing molecular integral file: moints! ***\n");
	  return err;
     } else {
	  fclose(fptr);
     }

     fptr = fopen("det.list", "r");
     if (fptr == NULL) {
	  err = 4;
	  fprintf(stderr,
		  "*** ERROR: Missing determinant list file! ***\n");
	  return err;
     } else {
	  fclose(fptr);
     }

     return err;
     
}
/* geninput: generate input for jayci.x 
 * -------------------------------------------------------------------
 * Input:
 *  dlen  = number of determinants
 *  alen  = number of alpha strings
 *  blen  = number of beta  strings
 *  aelec = number of alpha electrons
 *  belec = number of beta  electrons
 *  orbs  = number of orbitals
 *  nfrzc = number of frozen core orbitals
 *  nfrzv = number of frozen virtual orbitals */
int geninput(int dlen, int alen, int blen, int aelec, int belec, int orbs,
	     int nfrzc, int nfrzv)
{
     FILE *file;
     int err;
     
     err = 0;
     
     file = fopen("input.jayci","w");
     if (file == NULL) {
	  err = 1;
	  return err;
     }

     fprintf(file, "%15d\n", dlen);
     fprintf(file, "%15d\n", alen);
     fprintf(file, "%15d\n", blen);
     fprintf(file, "%15d\n", (aelec - nfrzc));
     fprintf(file, "%15d\n", (belec - nfrzc));
     fprintf(file, "%15d",   (orbs  - nfrzc - nfrzv));

     fclose(file);

     return err;
}

/*
 * print_array_2d: print 2d array
 */
void print_array_2d(double **array, int rows, int cols)
{
    int i, j;
    for (i = 0; i < rows; i++) {
	for (j = 0; j < cols; j++) {
	    fprintf(stdout, " %15.8lf ", array[j][i]);
	}
	fprintf(stdout,"\n");
    }
    return;
}

/*
 * print_civectors: print out ci vectors
 */
int print_civectors(double **civec, int ndets, int roots, double *cival)
{
	int error = 0; /* error flag */
	int i, j;
	FILE *fptr;
	/* Open file and print eigenvalues and eigenvectors */
	fptr = fopen("civector.dat", "w");
	if (fptr == NULL) {
		error = 1;
		error_flag(error, "print_civectors");
		return error;
	}
	fprintf(fptr, "%d\n\n", roots);
	for (i = 0; i < roots; i++) {
		fprintf(fptr, "%15.8lf\n\n", cival[i]);
		for (j = 0; j < ndets; j++) {
			fprintf(fptr, "%15.8lf\n", civec[i][j]);
		}
	}
	close(fptr);
	return error;
}

/* readdaiinput: read diagonalization algorithm input.
 * -------------------------------------------------------------------
 * Calls readnamelist which returns a chracter array
 *  nmlstr[0] = maxiter
 *  nmlstr[1] = krymin
 *  nmlstr[2] = krymax
 *  nmlstr[3] = nroots
 *  nmlstr[4] = prediagr
 *  nmlstr[5] = refdim
 *  nmlstr[6] = restol
 *
 * Output:
 *  maxiter = maximum iterations of davidson algorithm
 *  krymin  = minimum dimension of krylov space
 *  krymax  = maximum dimension of krylov space
 *  nroots  = number of roots to find
 *  prediagr= prediagonalization subroutine choice
 *  refdim  = intitial reference-space dimension (prediagonalization)
 *  restol  = convergence tolerance of residual
 *  err     = error handling: n = missing variable n */
void readdaiinput(int *maxiter,  int *krymin, int *krymax, int *nroots,
		  int *prediagr, int *refdim, double *restol, int *err)
{
    /* .. local scalars ..
     * gnml = namelist to read in */
    long long int gnml = 2;

    /* .. local arrays ..
     * nmlstr = namelist character arrays */
    char nmlstr[MAX_NAMELIST_SIZE][MAX_LINE_SIZE] = {{""},{""}};

    *err = 0;

    readnamelist_(&gnml, nmlstr, &err);
    if (err != 0) return;

    /* stream input into proper values */
    sscanf(nmlstr[0], "%d",  maxiter);
    sscanf(nmlstr[1], "%d",   krymin);
    sscanf(nmlstr[2], "%d",   krymax);
    sscanf(nmlstr[3], "%d",   nroots);
    sscanf(nmlstr[4], "%d", prediagr);
    sscanf(nmlstr[6], "%d",   refdim);
    sscanf(nmlstr[5], "%lf",  restol);
    
    return;
}
/* readgeninput: read general wavefunction input.
 * -------------------------------------------------------------------
 * Calls readnamelist which returns a character array
 *  nmlstr[0] = elec
 *  nmlstr[1] = orbs
 *  nmlist[2] = nfrozen
 *  nmlist[3] = ndocc
 *  nmlist[4] = nactive
 *  nmlist[5] = xlevel
 *  nmlist[6] = nfrzvirt
 *
 * Output:
 *  elec = number of electrons in system (alpha + beta)
 *  orbs = number of orbitals in system (including forzen core)
 *  nfrozen = number of frozen core orbitals
 *  ndocc = number of doubly-occupied orbitals
 *  nactive = number of active orbitals
 *  xlevel = excitaion level (Default is 2)
 *  nfrzvirt = number of frozen virtual orbitals
 *  err = error handling: n = missing variable n */
void readgeninput(int *elec,    int *orbs,   int *nfrozen,  int *ndocc,
	          int *nactive, int *xlevel, int *nfrzvirt, int *printlvl,
                  int *err)
{
     /* local scalars
      * gnml = namelist to read in */
     long long int gnml=1;
     
     /* local arrays
      * nmlstr = namelist character arrays */
     char nmlstr[MAX_NAMELIST_SIZE][MAX_LINE_SIZE] = {{""},{""}};
     

     *err = 0;

     /* read namelist 1 */
     readnamelist_(&gnml, nmlstr, &err);
     if (err != 0) return;

     /* stream the input into the proper variables */
     sscanf(nmlstr[0], "%d", elec);
     sscanf(nmlstr[1], "%d", orbs);
     sscanf(nmlstr[2], "%d", nfrozen);
     sscanf(nmlstr[3], "%d", ndocc);
     sscanf(nmlstr[4], "%d", nactive);
     sscanf(nmlstr[5], "%d", xlevel);
     sscanf(nmlstr[6], "%d", nfrzvirt);
     sscanf(nmlstr[7], "%d", printlvl);

     return;
     
}
/* readinputjayci: read the input file input.jayci
 * -------------------------------------------------------------------
 * Output:
 *  ci_aelec = ci alpha electrons
 *  ci_belec = ci beta  electrons
 *  ci_orbs  = ci orbitals
 *  nastr    = number of alpha strings
 *  nbstr    = number of beta  strings
 *  ndets    = number of ci determinants 
 * Returns:
 *  err = error handling */
int readinputjayci(int *ci_aelec, int *ci_belec, int *ci_orbs, int *nastr,
		   int *nbstr, int *ndets)
{
    FILE *inputfile;
    int err = 0;

    inputfile = fopen("input.jayci", "r");
    if (inputfile == NULL) {
	err = -1;
	return err;
    }

    fscanf(inputfile, " %d\n %d\n %d\n %d\n %d\n %d\n",
	   ndets, nastr, nbstr, ci_aelec, ci_belec, ci_orbs);

    return err;
    
}    
/* readmointegrals: Subroutine to read 1 and 2 electron integrals.
 * -------------------------------------------------------------------
 * Calls fortran subroutine readmoints()
 *
 * Input:
 *  itype     = type of integrals to read
 *  orbitals = MO's in system
 *  mofile   = name of molecular orbital file
 *  m1len    = length of moints1
 *  m2len    = length of moints2
 * Output:
 *  moints1  = 1-e integrals
 *  moints2  = 2-e integrals
 *  nuc_rep  = nuclear repulsion energy
 *  fcenergy = frozen-core energy */
void readmointegrals(double *moints1, double *moints2, int itype,
		     int orbitals, char *restrict moflname, int m1len,
		     int m2len, double *nuc_rep, double *fcenergy)
{
     long long int itype8, orbitals8, m1len8, m2len8;
     double energy[2];

     itype8 = (long long int) itype;
     orbitals8 = (long long int) orbitals;
     m1len8 = (long long int) m1len;
     m2len8 = (long long int) m2len;
     
     fprintf(stdout, "Calling readmoints_\n");
     fprintf(stdout, " Molecular integral file: %s\n", moflname);
     fprintf(stdout, " Type of integrals: %lld\n", itype8);
     fprintf(stdout, " 1-e integrals: %lld\n", m1len8);
     fprintf(stdout, " 2-e integrals: %lld\n", m2len8);
     /* call fortran subroutine */
     readmoints_(moints1, moints2, &itype8, &orbitals8, &m1len8,
		&m2len8, energy);
     *nuc_rep =  energy[0];
     *fcenergy = energy[1];
     return;
}
