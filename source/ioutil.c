// FILE: ioutil.c
/*********************************************************************
 * ioutil.c
 * --------
 * Contains routines for reading user input, molecular orbital input,
 * and writing output.
 *
 *
 * By Christopher L Malbon
 * Dept of Chemistry, The Johns Hopkins University
 ********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ioutil.h"

/** fortran subroutines **/
extern void _readmoints_(double *moints1, double *moints2,
			 long long int itype,
			 long long int orbitals,
			 long long int m1len,
			 long long int m2len,
			 double       *energy);

extern void _readnamelist_(long long int  nmlist,
			   unsigned char *nmlstr,
                           long long int *err);

extern void _readmocoef_(double *c, long long int clen);
/*************************/

/* check_for_file
 * --------------
 * Check if file exists and can be opened for desired operation.
 */
int check_for_file(char *filename, char *fileoperation)
{
        int iexists = 0;
        FILE *fptr = NULL;
        char error_message[80];
        fptr = fopen(filename, fileoperation);
        if (fptr == NULL){
                sprintf(error_message,"Cannot open file: '%s'; mode: '%s'!",
                       filename, fileoperation);
                iexists = 1;
                printf("Error: %s\n", error_message);
        }
        fclose(fptr);
        return iexists;
}

/* checkinputfiles
 * ---------------
 * Check for the following input files:
 *  (1) = jayci.in    = input file containing &general and &diagalg namelists
 *  (2) = input.jayci = input file generated by jayci_exp.x
 *  (3) = moints      = molecular integral file
 *  (4) = det.list    = determinant input list
 * Returns integer value of missing input file.
 */
int checkinputfiles()
{
     /* local scalars
      * err = error handling */
     int err = 0;

     err = check_for_file("jayci.in","r");
     if (err != 0) return err;
     err = check_for_file("input.jayci","r");
     if (err != 0) return err;
     err = check_for_file("moints","r");
     if (err != 0) return err;
     err = check_for_file("det.list","r");
     if (err != 0) return err;

     return err;
     
}

/* find_str_count_in_file: find occurances of string in file.
 * -------------------------------------------------------------------
 * Input:
 *  string = string to search for
 *  stream = file stream
 */
int find_str_count_in_file(char *string, FILE *fptr)
{
        int result = 0; /* Count */
        char tmp[MAX_LINE_SIZE];
        while (fgets(tmp, MAX_LINE_SIZE, fptr) != NULL) {
                if ((strstr(tmp, string)) != NULL) {
                        result++;
                }
        }
        if (result == 0) {
                result = -1;
        }
        return result;
}

/* find_str_line: find and return position in FILE *stream where string
 * first occurs.
 * -------------------------------------------------------------------
 * Input:
 *  string = string to search for
 *  stream = file stream
 */
FILE *find_str_line(char *string, FILE *fptr)
{
        char tmp[MAX_LINE_SIZE];
        fpos_t ptr;

        fgetpos(fptr, &ptr);
        while (fgets(tmp, MAX_LINE_SIZE, fptr) != NULL) {
                if ((strstr(tmp, string)) != NULL) {
                        fsetpos(fptr, &ptr);
                        return fptr;
                }
                fgetpos(fptr, &ptr);
        }
        return fptr;
}

/* geninput: generate input for jayci.x 
 * -------------------------------------------------------------------
 * Input:
 *  dlen  = number of determinants
 *  alen  = number of alpha strings
 *  blen  = number of beta  strings
 *  aelec = number of alpha electrons
 *  belec = number of beta  electrons
 *  orbs  = number of orbitals
 *  nfrzc = number of frozen core orbitals
 *  nfrzv = number of frozen virtual orbitals */
int geninput(int dlen, int alen, int blen, int aelec, int belec, int orbs,
	     int nfrzc, int nfrzv)
{
     FILE *file;
     int err;
     
     err = 0;
     
     file = fopen("input.jayci","w");
     if (file == NULL) {
	  err = 1;
	  return err;
     }

     fprintf(file, "%15d\n", dlen);
     fprintf(file, "%15d\n", alen);
     fprintf(file, "%15d\n", blen);
     fprintf(file, "%15d\n", (aelec - nfrzc));
     fprintf(file, "%15d\n", (belec - nfrzc));
     fprintf(file, "%15d",   (orbs  - nfrzc - nfrzv));

     fclose(file);

     return err;
}

/*
 * print_array_2d: print 2d array
 */
void print_array_2d(double **array, int rows, int cols)
{
    int i, j;
    for (i = 0; i < rows; i++) {
	for (j = 0; j < cols; j++) {
	    fprintf(stdout, " %15.8lf ", array[j][i]);
	}
	fprintf(stdout,"\n");
    }
    return;
}

/*
 * print_civectors: print out ci information and vectors
 */
int print_civectors(int aelec, int belec, int orbs, double **civec,
                    int ndets, int roots, double *cival)
{
	int error = 0; /* error flag */
        int tot_elec = 0; /* total electrons */
	int i, j;
	FILE *fptr;

        tot_elec = aelec + belec;
	/* Open file and print eigenvalues and eigenvectors */
	fptr = fopen("civector.dat", "w");
	if (fptr == NULL) {
		error = 1;
		error_flag(error, "print_civectors");
		return error;
	}
        fprintf(fptr, "%d %d %d\n", tot_elec, orbs, ndets);
	fprintf(fptr, "%d\n\n", roots);
	for (i = 0; i < roots; i++) {
		fprintf(fptr, "%15.8lf\n\n", cival[i]);
		for (j = 0; j < ndets; j++) {
			fprintf(fptr, "%15.12lf\n", civec[i][j]);
		}
                fprintf(fptr, "\n");
	}
	fclose(fptr);
	return error;
}

/*
 * read_civectors: read in ci information and vectors
 */
int read_civectors(int aelec, int belec, int orbs, double **civec,
                   int ndets, int roots, double *cival)
{
        int error = 0; /* error flag */
        int tot_elec = 0; /* total electrons */
        int fl_totelec, fl_ndets, fl_roots, fl_orbs; /* file values */
        int i, j;
        FILE *fptr;

        tot_elec = aelec + belec;
        /* Open file and read eigenvalues and eigenvetors */
        fptr = fopen("civector.dat", "r");
        if (fptr == NULL) {
                error = 1;
                error_flag(error, "read_civectors");
                return error;
        }
        fscanf(fptr, "%d %d %d\n", &fl_totelec, &fl_orbs, &fl_ndets);
        if (fl_totelec != tot_elec || fl_orbs != orbs ||
            fl_ndets != ndets) {
                error = 2;
                error_message("incorrect parameters", "read_civectors");
                error_flag(error, "read_civectors");
                return error;
        }
        fscanf(fptr, "%d\n\n", &fl_roots);
        if (fl_roots < roots) {
                error = 10 + fl_roots;
                error_message("File contains less roots than desired",
                              "read_civectors");
                error_flag(error, "read_civectors");
                return error;
        }
        for (i = 0; i < roots; i++) {
                fscanf(fptr, "%lf\n\n", &(cival[i]));
                for (j = 0; j < ndets; j++) {
                        fscanf(fptr, "%lf\n", &(civec[i][j]));
                }
                fscanf(fptr, "\n");
        }
        fclose(fptr);
        return error;
}

/* readdaiinput: read diagonalization algorithm input.
 * -------------------------------------------------------------------
 * Calls readnamelist which returns a chracter array
 *  nmlstr[0] = maxiter
 *  nmlstr[1] = krymin
 *  nmlstr[2] = krymax
 *  nmlstr[3] = nroots
 *  nmlstr[4] = prediagr
 *  nmlstr[5] = refdim
 *  nmlstr[6] = restol
 *
 * Output:
 *  maxiter = maximum iterations of davidson algorithm
 *  krymin  = minimum dimension of krylov space
 *  krymax  = maximum dimension of krylov space
 *  nroots  = number of roots to find
 *  prediagr= prediagonalization subroutine choice
 *  refdim  = intitial reference-space dimension (prediagonalization)
 *  restol  = convergence tolerance of residual
 *  err     = error handling: n = missing variable n */
void readdaiinput(int *maxiter,  int *krymin, int *krymax, int *nroots,
		  int *prediagr, int *refdim, double *restol, int *err)
{
    /* .. local scalars ..
     * gnml = namelist to read in */
    long long int gnml = 2;

    /* .. local arrays ..
     * nmlstr = namelist character arrays */
    char nmlstr[MAX_NAMELIST_SIZE][MAX_LINE_SIZE] = {{""},{""}};

    *err = 0;

    readnamelist_(&gnml, nmlstr, &err);
    if (err != 0) return;

    /* stream input into proper values */
    sscanf(nmlstr[0], "%d",  maxiter);
    sscanf(nmlstr[1], "%d",   krymin);
    sscanf(nmlstr[2], "%d",   krymax);
    sscanf(nmlstr[3], "%d",   nroots);
    sscanf(nmlstr[4], "%d", prediagr);
    sscanf(nmlstr[6], "%d",   refdim);
    sscanf(nmlstr[5], "%lf",  restol);
    
    return;
}

/* read_dysonorb_input: read dyson orbital input namelist file.
 * -------------------------------------------------------------------
 * Calls readnamelist which returns a character array
 * nmlstr[0] = wvfcn_file0: n+1 electron wavefunction
 * nmlstr[1] = wvfcn_file1: n   electron wavefunction
 * nmlstr[2] = nstates0: n+1 electron wavefunction states to read
 * nmlstr[3] = nstates1: n   electron wavefunction states to read
 * nmlstr[4] = nelecs0 : n+1 electrons
 * nmlstr[5] = nelecs1 : n   electrons
 * nmlstr[6] = norbs0  : n+1 orbitals
 * nmlstr[7] = norbs1  : n   orbitals
 * nmlstr[8] = ndets0  : n+1 determinants
 * nmlstr[9] = ndets1  : n   determinants
 * nmlstr[10]= ninto0  : n+1 electron internal orbitals
 * nmlstr[11]= ninto1  : n   electron internal orbitals
 */
void read_dysonorb_input(char *wvfcn_file0, char *wvfcn_file1, int *nstates0,
                         int *nstates1, int *nelecs0, int *nelecs1, int *norbs0,
                         int *norbs1, int *ndets0, int *ndets1, int *ninto0,
                         int *ninto1, int *err)
{
        /* dynml = 3, Read in dyson orbital namelist. */
        long long int dynml = 3; 
        char nmlstr[MAX_NAMELIST_SIZE][MAX_LINE_SIZE] = {{""},{""}};

        *err = 0;
        readnamelist_(&dynml, nmlstr, &err);
        if (err != 0) return;

        /* stream input into proper values */
        sscanf(nmlstr[0], "%s", wvfcn_file0);
        sscanf(nmlstr[1], "%s", wvfcn_file1);
        sscanf(nmlstr[2], "%d", nstates0);
        sscanf(nmlstr[3], "%d", nstates1);
        sscanf(nmlstr[4], "%d", nelecs0);
        sscanf(nmlstr[5], "%d", nelecs1);
        sscanf(nmlstr[6], "%d", norbs0);
        sscanf(nmlstr[7], "%d", norbs1);
        sscanf(nmlstr[8], "%d", ndets0);
        sscanf(nmlstr[9], "%d", ndets1);
        sscanf(nmlstr[10], "%d", ninto0);
        sscanf(nmlstr[11], "%d", ninto1);

        return;
}

/* readgeninput: read general wavefunction input.
 * -------------------------------------------------------------------
 * Calls readnamelist which returns a character array
 *  nmlstr[0] = elec
 *  nmlstr[1] = orbs
 *  nmlist[2] = nfrozen
 *  nmlist[3] = ndocc
 *  nmlist[4] = nactive
 *  nmlist[5] = xlevel
 *  nmlist[6] = nfrzvirt
 *  nmlist[7] = printlvl
 *  nmlist[8] = printwvf
 *
 * Output:
 *  elec = number of electrons in system (alpha + beta)
 *  orbs = number of orbitals in system (including forzen core)
 *  nfrozen = number of frozen core orbitals
 *  ndocc = number of doubly-occupied orbitals
 *  nactive = number of active orbitals
 *  xlevel = excitaion level (Default is 2)
 *  nfrzvirt = number of frozen virtual orbitals
 *  printlvl = print level
 *  printwvf = print wavefunctions (0: no; 1: yes)
 *  err = error handling: n = missing variable n */
void readgeninput(int *elec,     int *orbs,   int *nfrozen,  int *ndocc,
	          int *nactive,  int *xlevel, int *nfrzvirt, int *printlvl,
                  int *printwvf, int *err)
{
     /* local scalars
      * gnml = namelist to read in */
     long long int gnml=1;
     
     /* local arrays
      * nmlstr = namelist character arrays */
     char nmlstr[MAX_NAMELIST_SIZE][MAX_LINE_SIZE] = {{""},{""}};
     

     *err = 0;

     /* read namelist 1 */
     readnamelist_(&gnml, nmlstr, &err);
     if (err != 0) return;

     /* stream the input into the proper variables */
     sscanf(nmlstr[0], "%d", elec);
     sscanf(nmlstr[1], "%d", orbs);
     sscanf(nmlstr[2], "%d", nfrozen);
     sscanf(nmlstr[3], "%d", ndocc);
     sscanf(nmlstr[4], "%d", nactive);
     sscanf(nmlstr[5], "%d", xlevel);
     sscanf(nmlstr[6], "%d", nfrzvirt);
     sscanf(nmlstr[7], "%d", printlvl);
     sscanf(nmlstr[8], "%d", printwvf);

     return;
     
}

/* readinputjayci: read the input file input.jayci
 * -------------------------------------------------------------------
 * Output:
 *  ci_aelec = ci alpha electrons
 *  ci_belec = ci beta  electrons
 *  ci_orbs  = ci orbitals
 *  nastr    = number of alpha strings
 *  nbstr    = number of beta  strings
 *  ndets    = number of ci determinants 
 * Returns:
 *  err = error handling */
int readinputjayci(int *ci_aelec, int *ci_belec, int *ci_orbs, int *nastr,
		   int *nbstr, int *ndets)
{
    FILE *inputfile;
    int err = 0;

    inputfile = fopen("input.jayci", "r");
    if (inputfile == NULL) {
	err = -1;
	return err;
    }

    fscanf(inputfile, " %d\n %d\n %d\n %d\n %d\n %d\n",
	   ndets, nastr, nbstr, ci_aelec, ci_belec, ci_orbs);

    return err;
    
}

/* readmocoeffs: subroutine to read molecular coefficient file.
 * -------------------------------------------------------------------
 * Calls fortran subroutine readmocoef()
 *
 *
 */
void readmocoeffs(double *c, int clen)
{
        long long int maxlen;
        maxlen = (long long int) clen;
        readmocoef_(c, &maxlen);
        return;
}

/* readmointegrals: Subroutine to read 1 and 2 electron integrals.
 * -------------------------------------------------------------------
 * Calls fortran subroutine readmoints()
 *
 * Input:
 *  itype     = type of integrals to read
 *  orbitals = MO's in system
 *  mofile   = name of molecular orbital file
 *  m1len    = length of moints1
 *  m2len    = length of moints2
 * Output:
 *  moints1  = 1-e integrals
 *  moints2  = 2-e integrals
 *  nuc_rep  = nuclear repulsion energy
 *  fcenergy = frozen-core energy */
void readmointegrals(double *moints1, double *moints2, int itype,
		     int orbitals, char *restrict moflname, int m1len,
		     int m2len, double *nuc_rep, double *fcenergy)
{
     long long int itype8, orbitals8, m1len8, m2len8;
     double energy[2];

     itype8 = (long long int) itype;
     orbitals8 = (long long int) orbitals;
     m1len8 = (long long int) m1len;
     m2len8 = (long long int) m2len;
     
     fprintf(stdout, "Calling readmoints_\n");
     fprintf(stdout, " Molecular integral file: %s\n", moflname);
     fprintf(stdout, " Type of integrals: %lld\n", itype8);
     fprintf(stdout, " 1-e integrals: %lld\n", m1len8);
     fprintf(stdout, " 2-e integrals: %lld\n", m2len8);
     /* call fortran subroutine */
     readmoints_(moints1, moints2, &itype8, &orbitals8, &m1len8,
		&m2len8, energy);
     *nuc_rep =  energy[0];
     *fcenergy = energy[1];
     return;
}

/*
 * substring: gets substring from string and returns pointer to said
 * substring.
 */
char *substring(char *string, int position, int length)
{
        char *pointer;
        int c;

        pointer = malloc(length+1);
        if (pointer == NULL) {
                printf("Unable to allocate memory.\n");
                exit(1);
        }
        for (c = 0 ; c < length ; c++) {
                *(pointer+c) = *(string+position);
                string++;
        }
        *(pointer+c) = '\0';
        return pointer;
}
